# تمرین گروهی ۱.۱ - مستند طراحی

گروه ۲

-----

 > نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

پارسا صلواتی - parsa.salavati@gmail.com  
سپهر صفری - sepehr.safari8731@gmail.com  
علیرضا شاطری - alirezashateri7@gmail.com  
محمدحسین قیصریه - mgheysariyeh@gmail.com  

مقدمات

----------

> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  بنویسید.

> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.
> 
۱. https://stackoverflow.com/questions/32987351/unsure-how-to-work-with-mov-a-b-c-d  
۲. https://samwho.dev/blog/context-switching-on-x86/  
۳. https://en.wikipedia.org/wiki/Memory_management_unit  
۴. https://stackoverflow.com/questions/38360312/how-does-linux-kernel-switch-between-user-mode-and-kernel-mode-stack  
۵. https://stackoverflow.com/questions/66519900/how-is-current-context-saved-during-context-switching  
۶. http://www.jamesmolloy.co.uk/tutorial_html/6.-Paging.html  
۷. https://unix.stackexchange.com/questions/414314/was-unix-really-using-only-one-soft-interrupt-int-0x80-why  

پاس‌دادن آرگومان
============
داده‌ساختار‌ها
----------------

> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

متغیر `MAX_ARGS` برای مشخص کردن حداکثر تعداد آرگومان‌های ممکن برای اجرای یک فایل.

```c

#define MAX_ARGS 128

```




یک ساختار با اسم `args` به صورت زیر:

```c

struct args {

    int argc;

    char *argv[MAX_ARGS];

}

```




این داده‌ساختار برای نگه‌داری آرگومان‌ها پس از `tokenization` ورودی کاربر می‌باشد و برای راحتی انتقال داده‌ها استفاده می‌شود.

همچنین به تابع `load` نیز یک ورودی از نوع ساختار `args` اضافه می‌کنیم.

الگوریتم‌ها
------------

> به‌طور خلاصه توضیح دهید چگونه آرگومان‌ها را پردازش کرده‌اید؟ چگونه اعضای `argv[]` را به ترتیب درست در پشته قرار داده‌اید؟ و چگونه از سرریز پشته جلوگیری کرده‌اید؟

در تابع start_process از ماژول `userprog/process.c` ، ورودی تابع را که `file_name` است را، بر اساس فاصله‌ی یک اسپیس و با کمک تابع `strtok_r` به آرگومان‌هایش می‌شکنیم. سپس با خروجی این تابع `strtok_r` یک ساختار `args` می‌سازیم و فیلد‌های آن را نیز به کمک یک حلقه ست می‌کنیم. در فیلد `argc` تعداد و در آرایه‌ی `argv` خود آرگومان‌ها را نگه می‌داریم. همچنین همیشه در `argv[0]` نام فایل قرار دارد و در بقیه اعضای آرایه، آرگومان‌های داده شده توسط کاربر قرار می‌گیرند. بعد از ایجاد این داده‌ها، ساختار `args` ساخته شده را نیز همراه سایر  ورودی‌ها به تابع `load` پاس می‌دهیم.

در این تابع کارهای مربوط به پوش کردن آرگومان‌ها بر روی استک را انجام می‌دهیم. یعنی همانطور که می‌دانیم، باید آرگومان‌ها را بر از راست به چپ بر روی استک پوش کنیم تا اولی آرگومان در بالای استک قرار بگیرد، دومین آرگومان بعد از آن و الی آخر.

پس بعد از تعریف اولیه استک در `load` به کمک تابع `setup_stack`، این آرگومان‌ها را با یک حلقه‌ی `for` و با کمک ساختار `args` که به تابع `load` پاس داده بودیم، در استک پوش می‌کنیم. پوش کردن در استک نیز بدین صورت است که ابتدا به اندازه طول آرگومان `args->argv[i]` اشاره‌گر استک را کم می‌کنیم، سپس آرگومان `args->argv[i]` را در فضای خالی ایجاد شده قرار می‌دهیم. مقدار `i` هم از `args->argc-1` شروع و یکی یکی کم می‌شود تا به `0` برسد. همچنین یک اشاره‌گر به اولین آرگومان نگه می‌داریم.  در نهایت هم یک `return address` فیک پوش می‌کنیم که `null` است.

برای جلوگیری از `stack overflow` نیز اندازه صفحه‌ی استک (`stack page`) را با مجموع اندازه‌ی تمام آرگومان‌ها چم می‌کنیم، اگر آرگومان‌ها سایزشان از اندازه صفحه بیشتر شد، آنگاه `stack overflow` داریم و همانجا از اجرای برنامه خارج می‌شویم.

منطق طراحی
-----------------

> چرا Pintos به‌جای تابع‌ `strtok()` تابع‌ `strtok_r()` را پیاده‌سازی کرده‌است؟

در تابع `strtok`، نقطه‌ای که آخرین توکن پیدا شده را داخل خودش نگه می‌دارد تا در فراخوانی‌های بعدی بتواند از آن استفاده کند و توکن‌های بعدی را پیدا کند. در این صورت اگر ۲ `thread` مجزا این تابع را فراخوانی کنند ممکن است شرایط `race` پیش بیاید و یک `thread`از آخرین توکن پیدا شده توسط `thread` دیگر استفاده کند، در این صورت تابع به درستی کار نخواهد کرد.

اما تابع `strtok_r` این مشکل را حل کرد و `thread safe` است. این کار را به کمک یک متغیر کمکی به اسم `char **saveptr` انجام می‌دهد و دیگر درون خودش چیزی نگه‌ نمی‌دارد. با این کار می‌توان به صورت `concurrent` چند رشته‌ی مختلف را به توکن هایش تقسیم کرد.

> در Pintos عمل جدا کردن نام فایل از آرگومان‌ها، در داخل کرنل انجام می‌شود. در سیستم عامل‌های برپایه‌ی Unix، این عمل توسط shell انجام می‌شود. حداقل دو مورد از برتری‌های رویکرد Unix را توضیح دهید.

1. هندل کردن ارورها و همچنین چک کردن‌های بیشتر (`validation`)  بهتر است که سمت شل انجام شود. زیرا برای مثال ممکن است مقدار ورودی آنقدر بزرگ باشد یا حاوی کد مخرب باشد که به کرنل آسیب بزند، ولی اگر سمت شل باشد نهایتا باعث `crash` شدن خود شل می‌شود.

2. از سربار موجود روی کرنل کاسته می‌شود و می‌تواند به کارهای مهم‌تری بپردازد!

3. همچنین شل می‌تواند مقدار پیش پردازش بر روی ورودی‌ انجام دهد مانند ریدایرکشن، پایپ کردن و غیره.

فراخوانی‌های سیستمی
================
‫فراخوانی‌های سیستمی برای عملیات روی پرونده‌ها
-----------------
در این بخش در کل با ۳ چالش اصلی روبرو هستیم.

۱. فراخوانی توابع مربوط به عملیات روی پرونده‌ها که در فایل‌های file.c و filesys.c تعریف شده‌اند:

در این بخش ما باید فایل userprog/syscall.c را تغییر بدهیم. همان طور که در فایل هم معلوم هست در تابع syscall_handler در وضعیت فعلی صرفا حالتی که کد فراخوانی SYS_EXIT باشد چک شده است. ما باید این تکه را برای دیگر فراخوانی‌ها کامل کنیم و متغیر‌های 
لازم را درون frame اینتراپت اضافه کنیم.

۲. جلوگیری از صدا زدن چند تابع از file system به طور همزمان:

همان طور که در داک هم گفته شده بود، برای این بخش کافی است از یک قفل سراسری استفاده شود. این قفل می‌تواند semaphore و یا lock باشد. این قفل می‌تواند جاهای مختلفی تعریف شده باشد. مثلا میتوان آن را در thread.h و یا فایل‌های مربوط به سیستم فایل قرار داد. در ادامه کافی است هربار که یک عملیات از نوع کار با فایل انجام می‌دهیم، این قفل را بگیریم.

۳. جلوگیری از ایجاد تغییر در فایلی که در حال اجراست:

طبق داک از توابع file_allow_write و file_deny_write استفاده می‌کنیم. دقت شود فایل executable مهم هست و نه سورس کد. برای این کار باید هر موقع که تابع process_execute صدا زده شد، تابع file_deny_write را برای فایل executable صدا بزنیم. پس از این که تابع exec صدا زده شد، پراسس فعلی باید روی پراسس آن join کند و وقتی که کارش تمام شد، تابع file_allow_write را برای فایل مذکور صدا بزند. به این شکل race هم پیش نمی‌آید.

داده‌ساختار‌ها
----------------

> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ای.جاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

عملیات روی فایل:

در این قسمت به یک lock نیاز داریم  که چند عملیات روی فایل با هم انجام ندهیم. همچنین باید استراکت thread در src/threads/thread.h را هم کمی تغییر دهیم. به این صورت که باید یک آرایه یا linked list به آن اضافه کنیم و در آن اشاره‌گرهای به file descriptor (fd) ها را ذخیره کنیم، این بخش به طور کامل‌تر در پایین توضیح داده شده است. 
> توضیح دهید که توصیف‌کننده‌های فایل چگونه به فایل‌های باز مربوط می‌شوند. آیا این توصیف‌کننده‌ها در کل سیستم‌عامل به‌طور یکتا مشخص می‌شوند یا فقط برای هر پردازه یکتا هستند؟

با صدا کردن توابع در file.c یا filesys.c، این توابع به ما struct *file باز می‌گردانند. این استراکت تمامی اطلاعات مربوط به فایل باز شده را در خود دارد. برای دسترسی به آن می‌توان یک id فرضی برای آن در نظر گرفت. مانند fd های پیش‌فرض ۰ تا ۲ که ورودی و خروجی هستند.

حال باید در استراکت thread یک آرایه اضافه کنیم که خانه i ام آن به fd شماره i اشاره می‌کند. به این شکل می‌توان به آن fd دسترسی داشت (می‌توان به جای آرایه از linked list استفاده کرد). 

برای تخصیص id به هر fd هم می‌توان از ۰ شروع کرد و به سمت بالا حرکت کرد و اعداد طبیعی را به عنوان id در نظر گرفت.

الگوریتم‌ها
------------

> توضیح دهید خواندن و نوشتن داده‌های کاربر از داخل هسته، در کد شما چگونه انجام شده است.

از روش دوم در مستند استفاده می‌کنیم: بعد از خواندن هر پوینتر ابتدا صرفاً اطمینان حاصل می‌کنیم که در محدودهٔ مجاز کاربر (یعنی کمتر از `PHYS_BASE`) هست یا خیر و سپس آن را dereference می‌کنیم. در صورت نامعتبر بودن آدرس، page fault اتفاق می‌افتد که در آن برنامهٔ کاربر را تمام می‌کنیم.

> فرض کنید یک فراخوانی سیستمی باعث شود یک صفحه‌ی کامل (۴۰۹۶ بایت) از فضای کاربر در فضای هسته کپی شود. بیشترین و کمترین تعداد بررسی‌‌های جدول صفحات (page table) چقدر است؟ (تعداد دفعاتی که `pagedir_get_page()` صدا زده می‌شود.) در‌ یک فراخوانی سیستمی که فقط ۲ بایت کپی می‌شود چطور؟ آیا این عددها می‌توانند بهبود یابند؟ چقدر؟

اگر اطلاعات به گونه‌ای قرار گرفته باشند که در مرز بین ۲ صفحه باشند آنگاه برای کپی کردن ۲ بایت نیز ممکن است ۲ بار `pagedir_get_page()` را صدا بزنیم. اگر همواره بتوان تضمین کرد که اطلاعات در مرزها قرار نگرفته‌اند، آنگاه برای خواندن یک صفحهٔ کامل نیز نیاز به تنها یک بار صدا زدن `pagedir_get_page()` است.

> پیاده‌سازی فراخوانی سیستمی `wait` را توضیح دهید و بگویید چگونه با پایان یافتن پردازه در ارتباط است.

برای این کار تابع process_wait را کامل می‌کنیم. در این تابع یک semaphore وجود دارد که ترد صدا کننده وقتی به آن می‌رسد منتظر می‌ماند تا مثبت شود. این semaphore وقتی مثبت می‌شود که ترد فرزند آن را آپ کند و به این صورت به ترد پدر اطلاع دهد که کار ترد فرزند (خودش) تمام شده است. لازم به ذکر است که آزاد سازی منابع توسط خود ترد فرزند انجام می‌شود چون تابع process_exit که برای این کار هست، این کار را بر روی ترد صدا زننده انجام می‌دهد. همچنین حالت‌های پیچیده‌تری که ممکن است بین تردهای پدر و فرزند رخ دهد در سوال ۲ قسمت همگام سازی پاسخ داده شده است.

> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی `write‍` نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا (error handling) مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.

برای اینکه چک کنیم که اشاره‌گر به null اشاره می‌کند یا نه، به کمک یک if ساده این کار را انجام می‌دهیم، اگر اشاره‌گر به null اشاره کند، مقدار آن برابر با صفر یا به عبارتی false هست.

برای اینکه چک شود که اشاره‌گر به حافظه kernel اشاره نکند، می‌توان از تابع vaddr.h/is_user_vaddr استفاده کرد.

برای اینکه چک شود که اشاره‌گر به آدرس مجازی unmapped اشاره نکند، می‌توان از تابع pagedir.c/pagedir_get_page استفاده کرد. اگر که اشاره‌گر به unmapped اشاره کند، مقدار برگدانده شده از این تابع null خواهد بود.

اگر منبع تخصیص داده شده از نوع استاتیک باشد که منطقا می‌توان به نحوی به آن دسترسی پیدا کرد، مثلا اگر متغیری تعریف شده در یک فایل header باشد. اما اگر غیراستاتیک باشد می‌توان در یک استراکت جدید یا یکی از استراکت‌های تعریف شده فعلی، مثلا استراکت thread در فایل 	threads/thread.h، این منابع را تعریف کرد یا حداقل اشاره‌گری به آن‌ها قرار دهیم. به این صورت می‌توان به آن‌ها دسترسی داشت و اگر برنامه به خطا خورد آن‌ها را آزاد کرد.

همگام‌سازی
---------------

> فراخوانی سیستمی `exec` نباید قبل از پایان بارگذاری فایل اجرایی برگردد، چون در صورتی که بارگذاری فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که `exec` را فراخوانی کرده اطلاع داده می‌شود؟

تابع `process_execute` این کار را به طور کامل انجام می‌دهد. درواقع خود تابع بعد از اینکه پردازهٔ جدید را ساخت، `tid` آن را خروجی می‌دهد. در مدتی هم که این تابع در حال اجراست، از آن‌جا که داخل interrupt handler هستیم نیازی به کنترل خاص برای اجرا نشدن پردازهٔ والد نیست؛ چراکه خود مشغول اجرای دستورات برای ساخت پردازهٔ جدید است.

> پردازه‌ی والد P و پردازه‌ی فرزند C را درنظر بگیرید. هنگامی که P فراخوانی `wait(C)` را اجرا می‌کند و C  هنوز خارج نشده است، توضیح دهید که چگونه همگام‌سازی مناسب را برای جلوگیری از ایجاد شرایط مسابقه (race condition) پیاده‌سازی کرده‌اید. وقتی که C از قبل خارج شده باشد چطور؟ در هر حالت چگونه از آزاد شدن تمامی منابع اطمینان حاصل می‌کنید؟ اگر P بدون منتظر ماندن، قبل از C خارج شود چطور؟ اگر بدون منتظر ماندن بعد از C خارج شود چطور؟ آیا حالت‌های خاصی وجود دارد؟

برای آزاد سازی منابع تابع process_exit وجود دارد. ما باید از این تابع استفاده کنیم. از آنجایی که این تابع thread فعلی را به عنوان ورودی در نظر می‌گیرد، بنابراین باید هر thread زمانی که کارش به طور عادی تمام شد و یا exception خورد، منابع خود را نیز آزاد کند. برای حالتی که به طور عادی کار آن تمام شود، می‌توان در حالتی که exit syscall را اجرا می‌کنیم، منابع را هم آزاد کنیم. در حالتی که exception رخ دهد هم می‌توانیم توابع exception.c را مقداری عوض کنیم و با این کار در حین هندل کردن exception منابع را هم آزاد کنیم.

برای شرایط مختلف race هم مشکل در آن جا پیش می‌آید که پدر باید exit status فرزند را به هر نحو ممکن بتواند بدست بیاورد. برای این کار می‌توان در استراکت thread آی دی پدر و لیست فرزندان را نیز نگه داشت. به این صورت هر موقع که فرزند کارش تمام شد، exit status خود را در استراکت thread پدر خود می‌نویسد. به این صورت در حالت‌های مختلف که کار پدر و فرزند تمام شود، پدر می‌تواند در صورت نیاز به exit status فرزند دسترسی داشته باشد.

منطق طراحی
-----------------

> به چه دلیل روش دسترسی به حافظه سطح کاربر از داخل هسته را این‌گونه پیاده‌سازی کرده‌اید؟

> طراحی شما برای توصیف‌کننده‌های فایل چه نقاط قوت و ضعفی دارد؟

ما به یک آرایه یا linked list برای نگه داری اشاره‌گر‌های به fd ها در استراکت thread نیازمندیم. اگر از آرایه استفاده کنیم، یک مشکل اینست که حجم استراکت thread زیاد می‌شود. که این برخلاف توصیه داک هست. اگر از linked list استفاده کنیم، این مشکل رفع می‌شود چون فقط باید اشاره‌گر به linked list را در استراکت نگه داریم اما در مقابل زمان دسترسی به یک عضو مشخص از list نسبت به حالت آرایه بیشتر می‌شود چون باید کل list را پیمایش کنیم.

> در حالت پیش‌فرض نگاشت `tid` به `pid` یک نگاشت همانی است. اگر این را تغییر داده‌اید، روی‌کرد شما چه نقاط قوتی دارد؟

با توجه به این که process ها تک ترده هستند، این رویکرد به نظر مناسب است و هر process با ترد خود متناظر هست. همچنین جلوی پیچیده شدن بیش از حد را می‌گیرد.

سوالات افزون بر طراحی
===========

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی(esp) نامعتبر استفاده کرده است بیابید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.

این تست در آدرس `tests/userprog/sc-bad-sp.c` قرار دارد. در این تست ابتدا مقدار اشاره‌گر پشته به اندازه *64MB* پایین‌تر از *Code Segment* قرار می‌گیرد و سپس  یک سیستم کال انجام میگیرد، خروجی مورد انتظار این تست، `exit(-1)` است زیرا این مقدار استک به وضوح نامعتبر است. اگر خروجی `exit(-1)` نبود نیز تست شکست می‌خورد.

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی معتبر استفاده کرده ولی اشاره‌گر پشته آنقدر به مرز صفحه نزدیک است که برخی از آرگومان‌های فراخوانی سیستمی در جای نامعتبر مموری قرار گرفته اند مشخص کنید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.

این تست در آدرس `tests/userprog/sc-boundry-3.c` قرار دارد. در این تست ابتدا ناحیه‌ی مرزی یک *page* با ناحیه ممنوعه‌ی کرنل را می‌گیرد سپس مقدار ۱۰۰ را در آخرین خانه‌ی این *page* می‌گذارد. به گونه‌ای که تنها بایت اول آن در جای درستی قرار می‌گیرد و سایر بایت‌ها در جای نامعتری از حافظه می‌روند. در نهایت هم سیستم‌کال را اجرا می‌کند و خروجی مورد انتظار تست نیز کیل شدن پراسس مربوطه است. در غیر این صورت تست شکست می‌خورد.


> یک قسمت از خواسته‌های تمرین را که توسط مجموعه تست موجود تست نشده‌است، نام ببرید. سپس مشخص کنید تستی که این خواسته را پوشش بدهد چگونه باید باشد.

سیستم‌کال `tell` را هیچ تستی در تست‌های این پروژه پوشش نداده است. برای تست کردن این سیستم‌کال هم کافیست ابتدا یک فایل را باز کرده و پوینتر آن را تا مقداری که خودمان از آن اطلاع داریم جلو ببریم. سپس مقدار خروجی سیستم‌کال `tell` را با مقدار درست مقایسه کنیم که اگر درست بود یعنی تست پاس شده.

سوالات نظرخواهی
==============

پاسخ به این سوالات اختیاری است، ولی پاسخ به آن‌ها می‌تواند به ما در بهبود درس در ترم‌های آینده کمک کند. هر چه در ذهن خود دارید بگویید. این سوالات برای دریافت افکار شما هستند. هم‌چنین می‌توانید پاسخ خود را به صورت ناشناس در انتهای ترم ارائه دهید.

> به نظر شما، این تمرین یا هر یک از سه بخش آن، آسان یا سخت بودند؟ آیا وقت خیلی کم یا وقت خیلی زیادی گرفتند؟

> آیا شما بخشی را در تمرین یافتید که دید عمیق‌تری نسبت به طراحی سیستم عامل به شما بدهد؟

> آیا مسئله یا راهنمایی خاصی وجود دارد که بخواهید برای حل مسائل تمرین به دانشجویان ترم‌های آینده بگویید؟

> آیا توصیه‌ای برای دستیاران آموزشی دارید که چگونه دانشجویان را در ترم‌های آینده یا در ادامه‌ی ترم بهتر یاری کنند؟

> اگر نظر یا بازخورد دیگری دارید در این قسمت بنویسید.