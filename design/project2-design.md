
    # سیستم‌های عامل - تمرین گروهی دوم
    
    ## مشخصات گروه
    
    >> نام، نام خانوادگی و ایمیل خود را در ادامه وارد کنید.
    
    پارسا صلواتی - parsa.salavati@gmail.com
    
    سپهر صفری - sepehr.safari8731@gmail.com
    
    علیرضا شاطری - alirezashateri7@gmail.com
    
    محمدحسین قیصریه - mgheysariyeh@gmail.com
    
    ## مقدمه
    
    >> اگر نکته‌ای درباره فایل‌های سابمیت شده یا برای TAها دارید، لطفا اینجا بیان کنید.
    
    >> اگر از هر منبع برخط یا غیر برخطی به غیر از مستندات Pintos، متن درس، اسلایدهای درس یا نکات گفته شده در کلاس در تمرین گروهی استفاده کرده‌اید، لطفا اینجا آن(ها) را ذکر کنید.
    
    ## ساعت زنگ‌دار
    
    ### داده ساختارها
    
    >> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در 25 کلمه یا کمتر توضیح بنویسید.
    
    در فایل `thread.h` فیلدهای زیر را به ساختار `thread` اضافه می‌کنیم:
    
    ```
    struct thread {
            ...
            
            int64_t wakeup_time; /* When thread should be waked up from sleep */
            struct list_elem elem; /* Not new, comming from project 1 */
            ...
    
    };
    
    ```
    
    در فایل `timer.c` لیست پیوندی زیر را اضافه می‌کنیم:
    
    ```
    static struct lock sleep_threads_lock;
    
    static struct list sleep_threads; /* Holds sorted list of sleeped threads by wakeup_time */
    ```
    همچنین این تابع برای قرار دادن عضو جدید در لیست `sleep_threads`: 
    
    ```
    static bool wakeup_time_compare(struct list_elem *x, struct list_elem *y, void *dummy)
    {
            struct thread *t1 = list_entry(x, struct thread, elem);
            struct thread *t2 = list_entry(y, struct thread, elem);
            
            return (t1->alarm_time < t2->alarm_time);
    }
    ```
    
    
    ### الگوریتم
    
    >> پرسش دوم: به اختصار آن‌چه هنگام صدا زدن تابع `timer_sleep()` رخ می‌دهد و همچنین اثر `timer interrupt handler` را توضیح دهید.
    
    وقتی این تابع صدا زده می‌شود، ابتدا زمان بیدار شدن تردی که به خواب خواهد رفت محاسبه و در آن ذخیره می‌شود. این زمان برابر تعداد تیک‌های محاسبه شده از ابتدای شروع به کار کردن سیستم عامل است. سپس با گرفتن قفل `sleep_threads_lock` این ترد را به لیست `sleep_threads` به کمک تابعی که توسط خود کرنل پیاده سازی شده یعنی تابع `list_insert_ordered()` اضافه می‌کنیم. و بعد اضافه کردن ترد به لیست، تابع 
    `thread_block` را صدا می‌زنیم. در تابع `timer_interrupt()` هم باید از این قفل استفاده شود، یا بطور کلی هرجا که با لیست `sleep_threads` سر و کار داریم باید از این قفل برای دسترسی به آن استفاده کنیم. در تابع `sleep_threads` نیز اگر قفل آزاد بود، آن را می‌گیرد و از ابتدای لیست `sleep_threads` تمام تردهایی که زمان مناسب اجرا شدنشان با توجه به فیلد `wakeup_time` فرا رسیده باشد را پاپ و `tread_unblock` می‌کند.
    
    >> پرسش سوم: مراحلی که برای کوتاه کردن زمان صرف‌شده در `timer interrupt handler` صرف می‌شود را نام ببرید.
    
    چون داریم از لیست سورت شده استفاده میکنیم یعنی لیست `sleep_threads`، یافتن ترد‌هایی که زمان بیدار شدنشان رسیده و پاپ کردن هر کدام از اردر O(1) خواهد بود و در مجموع از O(n) است. 
    
    ### همگام‌سازی
    
    >> پرسش چهارم: هنگامی که چند ریسه به طور همزمان `timer_sleep()` را صدا می‌زنند، چگونه از `race condition` جلوگیری می‌شود؟
    
    با کمک قفل `sleep_threads_lock` مانع به وجود آمدن پوینتر های نا معتبر می‌شویم. یعنی قفل را که یک ترد میگیرد و درحال اضافه شدن به لیست `sleep_threads` است، نباید هیچ تردی از این لیست حذف شده باشد. 
    
    
    
    >> پرسش پنجم: هنگام صدا زدن `timer_sleep()` اگر یک وقفه ایجاد شود چگونه از `race condition` جلوگیری می‌شود؟
    
    همچنین ممکن است بعد از اضافه شدن به لیست `sleep_threads` و قبل از `thread_block` نیز `interrupt` رخ دهد که باید در هنگام پاپ کردن نیز وضعیت هر ترد بررسی شود. همچنین اگر این وقفه قبل از اضافه شدن به لیست `sleep_threads` رخ دهد مشکلی بوجود نمی آورد چون هنوز سراغ اضافه کردن به لیست نرفتیم.
    
    ### منطق
    
    >> پرسش ششم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.
    
    ابتدا ایده‌ی استفاده از هش مپ برای دسترسی به تردهایی زمان بیدار شدنشان فرا رسیده است، را بررسی کردیم. اما به دلیل پیچیدگی‌های احتمالی سراغ استفاده از لیست پیوندی مرتب شده رفتیم که پیاده سازی ان نیز در کرنل موجود است و کار با آن را ساده می‌کند.


## زمان‌بند اولویت‌دار

### داده ساختارها

>> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در ۲۵ کلمه یا کمتر توضیح بنویسید.


    struct thread {
      struct lock* thread_lock; /* used to prevent race during modifing thread data */
      struct list lock_priority_list; /* stores lock_priorities */
      int priority; /* thread basic priority */
      int eff_priority; /* thread effective priority */
      struct lock* waiting_lock; /* stores the lock which this thread is trying to acquire */ 
    }

>> پرسش دوم: داده‌ساختارهایی که برای اجرای `priority donation` استفاده شده‌است را توضیح دهید. (می‌توانید تصویر نیز قرار دهید)


    struct lock_priority {
      struct lock* lock; /* lock associated with */
      int priority; /* donated priority for this lock */
    }

هر ترد زمانی که سعی میکند یک قفل را acquire کند، زمانی که موفق به انجام این کار شد، یک نمونه از داده ساختار بالا را در لیست lock_priority_list خودش، اضافه میکند. در ادامه اگر که تردی دیگر بخواهد همین قفل را بگیرد، ماکزیمم مقدار effective_priority آن و مقدار priority داده ساختار بالا، در همان priority نوشته میشود. بدین صورت اگر چند ترد سعی کنند یه قفل را بگیرند یا دونیشن های تو در تو هم داشته باشیم، چون فقط مقدار ماکزیمم priority آن ها لازم هست، همین یک متغیر برای ذخیره سازی آن ها کافی است. دقت شود زمانی که اولویت یک ترد به ترد دیگری دونیت شود، امکان ندارد پس گرفته شود مگر زمانی که قفل آزاد شده باشد.

### الگوریتم

>> پرسش سوم: چگونه مطمئن می‌شوید که ریسه با بیشترین اولویت که منتظر یک قفل، سمافور یا `condition variable` است زودتر از همه بیدار می‌شود؟

در هر ۳ این داده ساختارها، در قسمتی از یک لیست که تردهای منتظر را در خود دارد، یک ترد به عنوان ترد بعدی، انتخاب میشود. مثلا برای سمافور در تابع sema_down این اتفاق میفتد. کافی است در اینجا به جای اینکه سر لیست را انتخاب کنیم، کل لیست را پیمایش کنیم و ترد با ماکزیمم eff_priority را انتخاب کنیم.

>> پرسش چهارم: مراحلی که هنگام صدازدن `lock_acquire()` منجر به `priority donation` می‌شوند را نام ببرید. دونیشن‌های تو در تو چگونه مدیریت می‌شوند؟

فرض کنیم ترد A میخواهد قفل را بگیرد. در ابتدا چک میکنیم که آیا قفل هم اکنون متعلق به ترد دیگری هست یا نه.
اگر نبود، باید مثل حالت عادی قفل را به ترد بدهیم و یک lock_priority به لیست lock_priority_list آن اضافه میکنیم که priority آن مثلا -۱ است. این بدین معناست که تردی به این قفل هیچ چیزی دونیت نکرده است.
اگر متعلق به ترد دیگری بود مثلا B، باید ابتدا دونیشن را انجام بدهیم و سپس مانند حالت عادی وارد لیست منتظرین قفل بشویم. برای دونیشن هم به این شکل عمل میکنیم که به وسیله متغیر holder در قفل، به ترد نگه دارند آن دسترسی داریم. حال لیست lock_priority_list ترد را بدست میاوریم. سپس با پیمایش آن المانی که قفل آن متناظر به قفل مذکور است را بدست میاوریم. سپس مقدار priority آن را به روز میکنیم. به این صورت که مثلا اگر eff_priority ترد A ۵۰ بود و priority در lock_priority مقدارش ۴۰ بود، آن را ۵۰ میکنیم. سپس مقدار eff_priority ترد B را به روز میکنیم. دقت شود چون ممکن است دونیشن تودرتو داشته باشیم، به کمک متغیر waiting_lock در ترد B، چک میکنیم که آیا ترد B هم اکنون منتظر قفل دیگری هست یا نه. اگر نبود که هیچی و گرنه همین دونیشن را برای waiting_lock هم باید انجام بدهیم. در واقع این کار را باید به کمک یه حلقه while یا یک تابع مجزا انجام داد. 

>> پرسش پنجم: مراحلی که هنگام صدا زدن `lock_release()` روی یک قفل که یک ریسه با اولویت بالا منتظر آن است، رخ می‌دهد را نام ببرید.

در کل به این صورت است که همان روند عادی رها کردن قفل را انجام میدهیم، فقط باید پس از آنکه از لیست lock→semaphore→waiters ترد بعدی را (همان که اولویت بالایی) دارد حذف کردیم، lock را به lock_priority_list آن اضافه میکنیم و eff_priority آن را به روز میکنیم.
برای تردی هم که قفل را آزاد کرده است کافی است که lock_priority مذکور از لیست lock_priority_list ترد حذف شود و دوباره eff_priority ترد به روز شود.

### همگام‌سازی

>> پرسش ششم: یک شرایط احتمالی برای رخداد `race condition` در `thread_set_priority` را بیان کنید و توضیح دهید که چگونه پیاده‌سازی شما از رخداد آن جلوگیری می‌کند. آیا می‌توانید با استفاده از یک قفل از رخداد آن جلوگیری کنید؟

در پیاده سازی ما thread_set_priority() مقدار priority را عوض میکند. بنابراین اگر مثلا تردی دیگر در همین حین در حال به روز کردن eff_priority همین ترد ما باشد ممکن است race پیش بیاید و مقدار نامعتبر بدست آید.
ما به کمک گرفتن و رها کردن thread_lock این مشکل را برطرف میکنیم.

### منطق

>> پرسش هفتم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.

به نظر خودمان یکی از خوبی های این طراحی اینست که همیشه مقدار eff_priority ترد، مقدار درست را در خود دارد و این مثلا پیاده سازی توابع thread_set&get_priority را ساده کرده است.
البته از طرفی این موضوع که ترد های دیگر باید eff_priority داخل ساختار ترد را تغییر دهند، تا حدی مشکلات race را به وجود میاورد که باید با همگام سازی مناسب آن ها را رفع کرد.

## سوالات افزون بر طراحی

>> پرسش هشتم: در کلاس سه صفت مهم ریسه‌ها که سیستم عامل هنگامی که ریسه درحال اجرا نیست را ذخیره می‌کند، بررسی کردیم:‍‍ `program counter` ، ‍‍‍`stack pointer` و `registers`. بررسی کنید که این سه کجا و چگونه در `Pintos` ذخیره می‌شوند؟ مطالعه ‍`switch.S` و تابع ‍`schedule` در فایل `thread.c` می‌تواند مفید باشد.

در فایل `switch.S`، در تابع `switch_threads` ابتدا رجیسترهای فعلی که مربوط ترد در حال اجرا می‌باشد را روی استک مربوط به این ترد قرار می‌دهد، با این کار رجیسترها را ذخیره می‌کند. سپس ادرس مربوط به استراکت ترد جاری را در رجیستر `eax` به عنوان خروجی تابع برای ریترن کردن قرار می‌دهد. بعد از آن استک پوینتر را نیز در قسمت مربوط به استک استراکت ترد ذخیره می‌کند. (آدرس این قسمت را قبلا به کمک `thread_stack_ofs` حساب کرده بود). بعد از آن ترد بعدی را می‌گیرد و استک پوینتر آن را در رجیستر `esp` قرار می‌دهد تا بازیابی شود. همچنین سایر رجیسترها را نیز از روی استک می‌خواند درون جای خود قرار می‌دهد. در نهایت هم اشاره‌گر به ترد قبلی را ریترن می‌کند. همچنین مقدار مربوط به `program counter`، در استراکت `intr_frame` که روی استک کرنل قرار دارد ذخیره میشود و در هنگام خوردن `interrupt` است که عمل بازیابی آن انجام می‌شود.

>> پرسش نهم: وقتی یک ریسه‌ی هسته در ‍`Pintos` تابع `thread_exit` را صدا می‌زند، کجا و به چه ترتیبی صفحه شامل پشته و `TCB` یا `struct thread` آزاد می‌شود؟ چرا این حافظه را نمی‌توانیم به کمک صدازدن تابع ‍`palloc_free_page` داخل تابع ‍`thread_exit` آزاد کنیم؟

وقتی تابع `thread_exit` صدا زده می شود، درون این تابع بعد از تغییر وضعیت ترد به `THREAD_DYING`، تابع `schedule()` را صدا می‌زند، در این تابع پس از انجام درست `switch_threads`، تابع `thread_schedule_tail` صدا زده می‌شود که در این تابع، چک می‌کند که اگر وضعیت ترد `THREAD_DYING` بود، صفحه‌ی مربوط به آن را پاک می‌کند.
درون تابع `thread_exit` نمی‌توان این کار را انجام داد چون هنگام `switch_threads` به این ترد همچنان نیاز داریم و باید بعد از انجام سوییچ، این ترد را پاک کنیم.

>> پرسش دهم: زمانی که تابع ‍`thread_tick` توسط `timer interrupt handler` صدا زده می‌شود، در کدام پشته اجرا می‌شود؟

چون درون هندل کردن یک `interrupt` هستیم، این تابع در پشته‌ی کرنل انجام می‌شود.


>> پرسش یازدهم: یک پیاده‌سازی کاملا کاربردی و درست این پروژه را در نظر بگیرید که فقط یک مشکل درون تابع ‍`sema_up()` دارد. با توجه به نیازمندی‌های پروژه سمافورها(و سایر متغیرهای به‌هنگام‌سازی) باید ریسه‌های با اولویت بالاتر را بر ریسه‌های با اولویت پایین‌تر ترجیح دهند. با این حال پیاده‌سازی ریسه‌های با اولویت بالاتر را براساس اولویت مبنا `Base Priority` به جای اولویت موثر ‍`Effective Priority` انتخاب می‌کند. اساسا اهدای اولویت زمانی که سمافور تصمیم می‌گیرد که کدام ریسه رفع مسدودیت شود، تاثیر داده نمی‌شود. تستی طراحی کنید که وجود این باگ را اثبات کند. تست‌های `Pintos` شامل کد معمولی در سطح هسته (مانند متغیرها، فراخوانی توابع، جملات شرطی و ...) هستند و می‌توانند متن چاپ کنند و می‌توانیم متن چاپ شده را با خروجی مورد انتظار مقایسه کنیم و اگر متفاوت بودند، وجود مشکل در پیاده‌سازی اثبات می‌شود. شما باید توضیحی درباره این که تست چگونه کار می‌کند، خروجی مورد انتظار و خروجی واقعی آن فراهم کنید.
 
 کارکرد: یک سمافور با مقدار اولیه صفر و یک قفل را تعریف می‌کنیم. ریسه‌ی ۱ با اولیت ۱ اجرا می‌‌کنیم و در آن ریسه‌های ۲ با اولیت ۲ و ۳ با اولیت ۳ را اجرا می‌کنیم و روی همین ریسه‌ ۱ تابع `thread_yield` را صدا می‌زنیم. ریسه‌ی ۳ روی سمافور تعریف شده، `down` می‌کند و بلاک می‌شود. ریسه‌ی ۲ هم قفل را می گیرد و ریسه‌ ۴ با اولیت ۴ را اجرا می‌کند و سپس ریسه‌ی ۲ هم روی سمافور، `down` می‌کند و بلاک می‌شود. ریسه‌ی ۴ هم قفل را `acquire` می‌کند و بلاک می‌شود. سپس ریسه‌۱ دوباره راه می افتد و به ترتیب `sema_up` و `thread_yield` و `sema_up` را صدا می‌زند. ریسه‌های ۲ و ۳ به ترتیب ۲ و ۳ را چاپ می‌کنند.
 
 خروجی مورد انتظار: عدد ۲ باید قبل از ۳ چاپ شود. زیرا بعد از `acquire` کردن قفل توسط ریسه‌۴، اولویت ریسه‌ ۲ به ۴ بر اثر دانیشن، افزایش می‌یابد و سمافور هم باید آن را برای اجرا انتخاب کند.
 
 خروجی واقعی: چون سمافور در انتخاب، اولویت پایه را مد نظر قرار می‌دهد، در خروجی ابتدا ۳ و سپس ۲ چاپ خواهد شد چون اولویت پایه‌ای ریسه‌۳ بیشتر از ریسه ۲ است

## سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد. نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست. ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>> به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>> آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>> آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>> آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>> آیا حرف دیگری دارید؟

