# گرازش نهایی تمرین گروهی ۱٫۱ - آشنایی با pintos

### شماره گروه: ۲

پارسا صلواتی - parsa.salavati@gmail.com  

سپهر صفری - sepehr.safari8731@gmail.com  

علیرضا شاطری - alirezashateri7@gmail.com  

محمدحسین قیصریه - mgheysariyeh@gmail.com  

------

## تقسیم‌بندی کار

مأموریت اول - پاس دادن آرگومان‌ها: علیرضا شاطری  

مأموریت دوم - فراخوانی‌های سیستمی برای کنترل پردازه‌ها:

 - کنترل دسترسی به حافظهٔ کاربر: پارسا صلواتی - محمدحسین قیصریه
 - practice: پارسا صلواتی

 - halt: سپهر صفری

 - exec: علیرضا شاطری - سپهر صفری

 - wait: سپهر صفری


مأموریت سوم - فراخوانی‌های سیستمی برای فایل‌سیستم: سپهر صفری

## تغییرات طراحی

### سیستم‌کال wait

در مورد این سیستم‌کال ما می‌خواستیم که کلا یک semaphore برای هر پدر و فرزند در نظر بگیریم تا پدر آن را down کند و فرزند در زمان اتمام آن را up کند، این semaphore قرار بود که در استراکت child که در پدر قرار داشت تعبیه شود، اما مشکل آن جا بود که اگر پدر زودتر از فرزند تمام می‌شد و می‌خواست تا منابع خود را آزاد کند، این semaphore هم از بین می‌رفت و در ادامه چون فرزند نمی‌دانست که این semaphore از بین رفته مشکل null dereferencing داشتیم. به همین خاطر به جای اینکه خود استراکت semaphore را در child ذخیره کنیم، اشاره‌گر به آن را ذخیره کردیم.

همچنین در ادامه متوجه شدیم که بعضی از داده‌ها بین پدر و فرزند مشترک هست و باید دسترسی به این داده‌ها سینکرون باشد. مثلا اشاره‌گر به thread فرزند در child ای که در پدر قرار دارد. به همین خاطر یک lock هم به child اضافه کردیم.  
همچنین برای کارکرد بهتر کد، به جای لیست از ‌hashmap استفاده کردیم.

### پاس دادن exit_code تابع thread_exit()

در این تابع ما به این احتیاج پیدا کردیم که exit_code پراسس را هم پاس بدهیم، تا در ادامه با پاس دادن آن به process_exit()، پراسس فرزند exit_code خود را در پدرش (در صورت زنده بودن) مقداردهی کند.


